// DigitalRune Engine - Copyright (C) DigitalRune GmbH
// This file is subject to the terms and conditions defined in
// file 'LICENSE.TXT', which is part of this source code package.

using System;
using DigitalRise.Data.Materials;
using DigitalRise.Data.Meshes;
using DigitalRise.Geometry.Shapes;
using DigitalRise.Mathematics.Algebra;


namespace DigitalRise.Misc
{
	/// <summary>
	/// Creates and caches <see cref="Submesh"/>es for <see cref="Shape"/>s.
	/// </summary>
	/// <remarks>
	/// <para>
	/// Whenever you have a shape and need a submesh, you can use this class.
	/// The returned submesh must not be modified because it might be shared. Every time you use the 
	/// submesh, check if it was disposed. This happens if the shape was changed.
	/// </para>
	/// <para>
	/// This class can also keep submeshes alive (using a strong reference) for a certain amount of 
	/// time. This is useful for the <see cref="DebugRenderer"/>, which get the submeshes regularly.
	/// </para>
	/// </remarks>
	internal static class ShapeMeshCache
	{
		private class MeshTagData
		{
			public Submesh Submesh;
			public Matrix44F Matrix;
		}

		// A special submesh without vertex buffer or index buffer. Represents an "empty" submesh.
		// This allows to distinguish an empty submesh from "null" values.
		private static readonly Submesh EmptySubmesh = new Submesh();

		/// <summary>
		/// Gets or sets the allowed relative mesh error.
		/// </summary>
		/// <value>The allowed relative error for meshes; in the range ]0, 1[.</value>
		/// <remarks>
		/// If triangle meshes are generated to draw curved shapes, the meshes are approximated with 
		/// this relative error value. 
		/// </remarks>
		public static float MeshRelativeError
		{
			get { return _meshRelativeError; }
			set { _meshRelativeError = value; }
		}
		private static float _meshRelativeError = 0.01f;


		/// <summary>
		/// Gets or sets the iteration limit for approximated meshes.
		/// </summary>
		/// <value>The iteration limit for approximated meshes. (Must be greater than 0.)</value>
		/// <remarks>
		/// If the mesh is generated by an iterative algorithm, no more than 
		/// <see cref="MeshIterationLimit"/> iterations are performed.
		/// </remarks>
		/// <exception cref="ArgumentOutOfRangeException">
		/// <paramref name="value"/> is 0 or negative.
		/// </exception>
		public static int MeshIterationLimit
		{
			get { return _meshIterationLimit; }
			set
			{
				if (_meshIterationLimit <= 0)
					throw new ArgumentOutOfRangeException("value", "MeshIterationLimit must be greater than 0.");

				_meshIterationLimit = value;
			}
		}
		private static int _meshIterationLimit = 4;

		/// <summary>
		/// Gets or sets the normal angle limit which determines when vertex normal vectors of neighbor
		/// triangles can be merged.
		/// </summary>
		/// <value>
		/// The normal angle limit in radians. If the angle between two normal vectors is less than this
		/// value, the normals can be merged.
		/// </value>
		public static float NormalAngleLimit
		{
			get { return _normalAngleLimit; }
			set { _normalAngleLimit = value; }
		}
		private static float _normalAngleLimit = Mathematics.MathHelper.ToRadians(70);

		private static void UpdateMeshTag(Shape shape)
		{
			if (shape.MeshTag != null)
			{
				return;
			}

			// Use a special shared submesh for box shapes.
			var mtd = new MeshTagData();
			do
			{
				var boxShape = shape as BoxShape;
				if (boxShape != null)
				{
					mtd.Submesh = InternalPrimitives.UntexturedBox;
					mtd.Matrix = Matrix44F.CreateScale(boxShape.Extent);
					break;
				}

				var transformedShape = shape as TransformedShape;
				boxShape = (transformedShape != null) ? transformedShape.Shape as BoxShape : null;
				if (boxShape != null)
				{
					mtd.Submesh = InternalPrimitives.UntexturedBox;
					mtd.Matrix = transformedShape.Pose
							 * Matrix44F.CreateScale(transformedShape.Scale * boxShape.Extent);
					break;
				}

				// Create the submesh. Return EmptySubmesh if the MeshHelper returns null.
				var newSubmesh = MeshHelper.CreateSubmesh(
				  DR.GraphicsDevice,
				  shape.GetMesh(MeshRelativeError, MeshIterationLimit),
				  NormalAngleLimit);

				mtd.Submesh = newSubmesh ?? EmptySubmesh;
				mtd.Matrix = Matrix44F.Identity;
			}
			while (false);

			shape.MeshTag = mtd;
		}

		public static void GetSubmesh(this Shape shape, out Submesh submesh, out Matrix44F matrix)
		{
			UpdateMeshTag(shape);

			var data = (MeshTagData)shape.MeshTag;
			submesh = data.Submesh;
			matrix = data.Matrix;
		}
	}
}